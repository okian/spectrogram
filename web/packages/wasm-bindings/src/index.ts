/**
 * WASM bindings loader and typed facade over spectro_dsp crate.
 * What: Provides safe, validated access to the Rust DSP routines compiled to WebAssembly.
 * Why: Keeps application code decoupled from wasm-bindgen internals while enforcing defensive checks.
 */

// Type describing the subset of functions we use from the generated wasm package.
interface WasmModule {
  /** Forward real-to-complex FFT implemented in Rust. */
  fft_real(input: Float32Array): Float32Array;
  /** Apply a window function to the input buffer. */
  apply_window(input: Float32Array, window_type: string): Float32Array;
  /** Full STFT frame: window + FFT + magnitude. */
  stft_frame(
    input: Float32Array,
    window_type: string,
    reference: number,
  ): Float32Array;
  /** Magnitude spectrum computation in dBFS. */
  magnitude_dbfs(input: Float32Array, reference: number): Float32Array;
  /** Exposed linear memory for low level diagnostics. */
  memory: WebAssembly.Memory;
  /** Default init function generated by wasm-bindgen. */
  default(): Promise<void>;
}

/** Supported window types for WASM routines. */
const WINDOW_TYPES = [
  'hann',
  'hamming',
  'blackman',
  'none'
] as const;

/**
 * Path to the wasm-bindgen generated JS glue relative to this module.
 * Why: centralize the location to avoid fragile hard-coded paths.
 */
const WASM_PKG_JS_PATH = '../pkg/spectro_dsp.js';

/** Error code emitted when a dynamic import cannot resolve a module. */
const MODULE_NOT_FOUND_CODE = 'ERR_MODULE_NOT_FOUND';
/** Error code produced when a file-backed fetch cannot locate the resource. */
const FILE_NOT_FOUND_CODE = 'ENOENT';
/** Substring present in browser errors when fetching a module fails. */
const FAILED_TO_FETCH_MSG = 'Failed to fetch';
/** Substring present in Firefox network failures. */
const NETWORK_ERROR_MSG = 'NetworkError';

/** Default reference level used when converting to dBFS. */
const DEFAULT_REFERENCE_LEVEL = 1.0;

/** Cached WASM module once initialised for reuse across calls. */
let wasmModule: WasmModule | null = null;
/** Tracks ongoing initialization to deduplicate concurrent requests. */
let initPromise: Promise<WasmModule> | null = null;

/**
 * Ownership: arrays returned by exported helpers view the module's linear memory.
 * If persistent data is needed, pass an `output` buffer or copy the result.
 */

/**
 * Initialize the WASM module (idempotent).
 * How: dynamically import the wasm-bindgen generated package and call its default init.
 */
export async function initWasm(): Promise<WasmModule> {
  if (wasmModule) return wasmModule;
  if (initPromise) return initPromise;

  initPromise = (async () => {
    try {
      // WASM loader lacks type declarations; ignore for type checking.
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore – wasm-pack generated module has no types.
      const mod = await import(WASM_PKG_JS_PATH);
      if (!mod?.default || typeof mod.default !== 'function') {
        initPromise = null;
        throw new Error('WASM module missing default initialization function');
      }
      await mod.default();
      // After initialization the module functions are ready to use.
      wasmModule = mod as unknown as WasmModule;
      return wasmModule;
    } catch (error) {
      // Reset promise on failure to allow subsequent retries.
      initPromise = null;
      const err = error as { code?: string; message?: string };
      if (
        err.code === MODULE_NOT_FOUND_CODE ||
        err.code === FILE_NOT_FOUND_CODE ||
        (err.message &&
          (err.message.includes(FAILED_TO_FETCH_MSG) ||
            err.message.includes(NETWORK_ERROR_MSG)))
      ) {
        throw new Error(`WASM bundle not found at ${WASM_PKG_JS_PATH}`);
      }
      throw error;
    }
  })();

  return initPromise;
}

/**
 * Compute FFT (real→complex interleaved) via WASM.
 * What: forwards to the Rust implementation without copying by default.
 * Why: callers may reuse the returned buffer directly to avoid allocations.
 * How: optionally copies into `output` when provided to retain ownership.
 */
export async function fftReal(
  input: Float32Array,
  output?: Float32Array,
): Promise<Float32Array> {
  if (!(input instanceof Float32Array)) {
    throw new TypeError('fftReal expects a Float32Array input');
  }
  if (input.length === 0) {
    throw new Error('fftReal requires a non-empty input array');
  }
  if (output !== undefined && !(output instanceof Float32Array)) {
    throw new TypeError('fftReal output buffer must be a Float32Array');
  }
  const wasm = await initWasm();
  const result = wasm.fft_real(input);
  if (output) {
    if (output.length !== result.length) {
      throw new Error(
        `fftReal output length ${output.length} does not match ${result.length}`,
      );
    }
    output.set(result);
    return output;
  }
  // The returned array views WASM memory that may be reused; copy or supply `output` to retain data.
  return result;
}

/**
 * Apply a window function to the input buffer via WASM.
 * What: delegates to Rust windowing without copying unless `output` supplied.
 * Why: allows callers to reuse buffers and control ownership of data.
 * How: writes into `output` when provided; otherwise returns a view into WASM memory.
 */
export async function applyWindow(
  input: Float32Array,
  windowType: 'hann' | 'hamming' | 'blackman' | 'none',
  output?: Float32Array,
): Promise<Float32Array> {
  if (!(input instanceof Float32Array)) {
    throw new TypeError('applyWindow expects a Float32Array input');
  }
  if (input.length === 0) {
    throw new Error('applyWindow requires a non-empty input array');
  }
  if (!WINDOW_TYPES.includes(windowType)) {
    throw new Error(`Unknown window type: ${windowType}`);
  }
  if (output !== undefined && !(output instanceof Float32Array)) {
    throw new TypeError('applyWindow output buffer must be a Float32Array');
  }
  const wasm = await initWasm();
  const resolvedType = windowType === 'none' ? 'rect' : windowType;
  const result = wasm.apply_window(input, resolvedType);
  if (output) {
    if (output.length !== result.length) {
      throw new Error(
        `applyWindow output length ${output.length} does not match ${result.length}`,
      );
    }
    output.set(result);
    return output;
  }
  // Returned array aliases WASM memory that may be recycled; provide `output` or copy to keep values.
  return result;
}

/**
 * Compute complete STFT frame: window + FFT + magnitude via WASM.
 * What: performs the entire pipeline while avoiding copies unless `output` is given.
 * Why: callers can reuse buffers or retain results deterministically.
 * How: copies into `output` when provided; otherwise returns WASM memory directly.
 */
export async function stftFrame(
  input: Float32Array,
  windowType: 'hann' | 'hamming' | 'blackman' | 'none',
  reference: number = DEFAULT_REFERENCE_LEVEL,
  output?: Float32Array,
): Promise<Float32Array> {
  if (!(input instanceof Float32Array)) {
    throw new TypeError('stftFrame expects a Float32Array input');
  }
  if (input.length === 0) {
    throw new Error('stftFrame requires a non-empty input array');
  }
  if (!WINDOW_TYPES.includes(windowType)) {
    throw new Error(`Unknown window type: ${windowType}`);
  }
  if (!Number.isFinite(reference) || reference <= 0) {
    throw new Error('reference must be a positive finite number');
  }
  if (output !== undefined && !(output instanceof Float32Array)) {
    throw new TypeError('stftFrame output buffer must be a Float32Array');
  }
  const wasm = await initWasm();
  const resolvedType = windowType === 'none' ? 'rect' : windowType;
  const result = wasm.stft_frame(input, resolvedType, reference);
  if (output) {
    if (output.length !== result.length) {
      throw new Error(
        `stftFrame output length ${output.length} does not match ${result.length}`,
      );
    }
    output.set(result);
    return output;
  }
  // The returned array references WASM memory that may be overwritten later; copy or use `output` to persist.
  return result;
}

/**
 * Compute magnitude spectrum in dBFS from a real block in WASM.
 * What: performs only magnitude conversion with optional copy into `output`.
 * Why: callers may reuse buffers to avoid allocations and maintain ownership.
 * How: returns WASM memory directly when no `output` is supplied.
 */
export async function magnitudeDbfs(
  input: Float32Array,
  reference: number = DEFAULT_REFERENCE_LEVEL,
  output?: Float32Array,
): Promise<Float32Array> {
  if (!(input instanceof Float32Array)) {
    throw new TypeError('magnitudeDbfs expects a Float32Array input');
  }
  if (input.length === 0) {
    throw new Error('magnitudeDbfs requires a non-empty input array');
  }
  if (!Number.isFinite(reference) || reference <= 0) {
    throw new Error('reference must be a positive finite number');
  }
  if (output !== undefined && !(output instanceof Float32Array)) {
    throw new TypeError('magnitudeDbfs output buffer must be a Float32Array');
  }
  const wasm = await initWasm();
  const result = wasm.magnitude_dbfs(input, reference);
  if (output) {
    if (output.length !== result.length) {
      throw new Error(
        `magnitudeDbfs output length ${output.length} does not match ${result.length}`,
      );
    }
    output.set(result);
    return output;
  }
  // Result aliases WASM memory that may be recycled; copy or use `output` to retain values.
  return result;
}

/** Spectro meta DTO mirrored from Rust for convenience. */
export interface SpectroMetaDto {
  streamId: string;
  channels: number;
  sampleRateHz: number;
  nfft: number;
  hopSize: number;
}
