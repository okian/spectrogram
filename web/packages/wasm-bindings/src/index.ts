/**
 * WASM bindings loader and typed facade over spectro_dsp crate.
 * What: Provides safe, validated access to the Rust DSP routines compiled to WebAssembly.
 * Why: Keeps application code decoupled from wasm-bindgen internals while enforcing defensive checks.
 */

// Type describing the subset of functions we use from the generated wasm package.
interface WasmModule {
  /** Forward real-to-complex FFT implemented in Rust. */
  fft_real(input: Float32Array): Float32Array;
  /** Apply a window function to the input buffer. */
  apply_window(input: Float32Array, window_type: string): Float32Array;
  /** Full STFT frame: window + FFT + magnitude. */
  stft_frame(input: Float32Array, window_type: string, reference: number): Float32Array;
  /** Magnitude spectrum computation in dBFS. */
  magnitude_dbfs(input: Float32Array, reference: number): Float32Array;
  /** Exposed linear memory for low level diagnostics. */
  memory: WebAssembly.Memory;
  /** Default init function generated by wasm-bindgen. */
  default(): Promise<void>;
}

/** Supported window types for WASM routines. */
const WINDOW_TYPES = [
  'hann',
  'hamming',
  'blackman',
  'none'
] as const;

/**
 * Path to the wasm-bindgen generated JS glue relative to this module.
 * Why: centralize the location to avoid fragile hard-coded paths.
 */
const WASM_PKG_JS_PATH = '../pkg/spectro_dsp.js';

let wasmModule: WasmModule | null = null;
let initPromise: Promise<WasmModule> | null = null;

/**
 * Initialize the WASM module (idempotent).
 * How: dynamically import the wasm-bindgen generated package and call its default init.
 */
export async function initWasm(): Promise<WasmModule> {
  if (wasmModule) return wasmModule;
  if (initPromise) return initPromise;

  initPromise = (async () => {
    try {
      // WASM loader lacks type declarations; ignore for type checking.
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore – wasm-pack generated module has no types.
      const mod = await import(WASM_PKG_JS_PATH);
      if (!mod?.default || typeof mod.default !== 'function') {
        initPromise = null;
        throw new Error('WASM module missing default initialization function');
      }
      await mod.default();
      // After initialization the module functions are ready to use.
      wasmModule = mod as unknown as WasmModule;
      return wasmModule;
    } catch (error) {
      // Reset promise on failure to allow subsequent retries.
      initPromise = null;
      throw error;
    }
  })();

  return initPromise;
}

/**
 * Compute FFT (real→complex interleaved) via WASM.
 * Validates input prior to dispatch.
 */
export async function fftReal(input: Float32Array): Promise<Float32Array> {
  if (!(input instanceof Float32Array)) {
    throw new TypeError('fftReal expects a Float32Array input');
  }
  if (input.length === 0) {
    throw new Error('fftReal requires a non-empty input array');
  }
  const wasm = await initWasm();
  return wasm.fft_real(input).slice();
}

/**
 * Apply a window function to the input buffer via WASM.
 * Ensures the window type is recognised.
 */
export async function applyWindow(
  input: Float32Array,
  windowType: 'hann' | 'hamming' | 'blackman' | 'none',
): Promise<Float32Array> {
  if (!(input instanceof Float32Array)) {
    throw new TypeError('applyWindow expects a Float32Array input');
  }
  if (input.length === 0) {
    throw new Error('applyWindow requires a non-empty input array');
  }
  if (!WINDOW_TYPES.includes(windowType)) {
    throw new Error(`Unknown window type: ${windowType}`);
  }
  const wasm = await initWasm();
  const resolvedType = windowType === 'none' ? 'rect' : windowType;
  return wasm.apply_window(input, resolvedType).slice();
}

/**
 * Compute complete STFT frame: window + FFT + magnitude via WASM.
 * Validates parameters before invoking the Rust routine.
 */
export async function stftFrame(
  input: Float32Array,
  windowType: 'hann' | 'hamming' | 'blackman' | 'none',
  reference = 1.0,
): Promise<Float32Array> {
  if (!(input instanceof Float32Array)) {
    throw new TypeError('stftFrame expects a Float32Array input');
  }
  if (input.length === 0) {
    throw new Error('stftFrame requires a non-empty input array');
  }
  if (!WINDOW_TYPES.includes(windowType)) {
    throw new Error(`Unknown window type: ${windowType}`);
  }
  if (!Number.isFinite(reference) || reference <= 0) {
    throw new Error('reference must be a positive finite number');
  }
  const wasm = await initWasm();
  const resolvedType = windowType === 'none' ? 'rect' : windowType;
  return wasm.stft_frame(input, resolvedType, reference).slice();
}

/**
 * Compute magnitude spectrum in dBFS from a real block in WASM.
 * Ensures numeric parameters are valid before dispatch.
 */
export async function magnitudeDbfs(
  input: Float32Array,
  reference = 1.0,
): Promise<Float32Array> {
  if (!(input instanceof Float32Array)) {
    throw new TypeError('magnitudeDbfs expects a Float32Array input');
  }
  if (input.length === 0) {
    throw new Error('magnitudeDbfs requires a non-empty input array');
  }
  if (!Number.isFinite(reference) || reference <= 0) {
    throw new Error('reference must be a positive finite number');
  }
  const wasm = await initWasm();
  return wasm.magnitude_dbfs(input, reference).slice();
}

/** Spectro meta DTO mirrored from Rust for convenience. */
export interface SpectroMetaDto {
  streamId: string;
  channels: number;
  sampleRateHz: number;
  nfft: number;
  hopSize: number;
}
